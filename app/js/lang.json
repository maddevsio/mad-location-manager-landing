{
    "ru": {
        "main-menu_item1": "Главная",
        "main-menu_item2": "Зачем нужен фильтр?",
        "main-menu_item3": "Что умеет?",
        "main-menu_item4": "Как работает?",
        "main-menu_item5": "Как использовать?",
        "main-menu_item6": "Кто сделал?",
        "main-menu_item7": "in english",
        "logo_desc": "Точные и «чистые» данные с датчиков GPS",
        "lang-toggle": "in english",
        "main_title": "Фильтр ошибок GPS датчиков",
        "without_filter": "без фильтра",
        "with_filter": "с фильтром",
        "lib_github": "Библиотека на GitHub",
        "main-banner_or": "или",
        "docs": "Документация и теория",
        "why-is-this_title": "Зачем нужен фильтр?",
        "why-is-this_p1": "Устали от «лишних» километров из за GPS в приложении такси?",
        "why-is-this_p2": "Постоянные «скачки» GPS в приложении для учета передвижения курьеров?",
        "why-is-this_p3": "Есть потребность в точном трекинге в любом on-demand сервисе?",
        "why-is-this_subtitle": "Решение - Mad Location Manager",
        "features_title": "Что умеет Mad Location Manager?",
        "features_p1": "Уменьшает ошибки трекинга маршрута",
        "features_p2": "Не накручивает дистанцию для неподвижных объектов",
        "features_p3": "Исключает резкие «скачки» координат в точки, удаленные от реального маршрута",
        "features_p4": "Позволяет сделать плавным движение объектов на карте",
        "features_p5": "Уменьшает шумы с датчиков телефонов низкого класса",
        "features_p6": "Фильтрует ошибки при кратковременной потере GPS сигнала",
        "features_subtitle": "И другие задачи, связанные с доставкой и трекингом движущихся объектов на карте",
        "features_how_work": "Как работает?",
        "how-it-work_title": "Как работает?",
        "how-it-work_subtitle": "Для реализации задачи нам необходимы данные с трех датчиков:",
        "how-it-work_item1_title": "Магнитометр",
        "how-it-work_item1_desc": "Этот датчик помогает определить, где север",
        "how-it-work_item2_title": "Акселерометр",
        "how-it-work_item2_desc": "Используется для определения ускорения тела и угла наклона",
        "how-it-work_item3_title": "Гироскоп",
        "how-it-work_item3_desc": "Позволяет найти текущее положение объекта, зная начальное положение устройства и проинтегрировав показания гироскопа",
        "android-sensors_title": "Самыми простыми и удобными оказались виртуальные датчики Android",
        "rotation_vector_title": "У нас есть вектор ускорения в «абсолютной» системе координат поэтому можно приступать к реализации фильтра Калмана",
        "rotation_vector_item1_title": "Виртуальные датчики Android",
        "rotation_vector_item1_desc": "Чтобы определить ускорение, можно воспользоваться датчиком LINEAR_ACCELEROMETER, который выдает ускорения относительно осей телефона. Для определения ориентации в пространстве можно использовать ROTATION_VECTOR",
        "rotation_vector_item2_title": "Фильтр Калмана",
        "rotation_vector_item2_desc": "Определяем вектор состояния системы, матрицу перехода, управляющий вектор и прочие компоненты фильтра Калмана. Определяем ковариационные матрицы шума процесса и шума измерений. В такой форме довольно легко расширить фильтр",
        "rotation_vector_simple": "А если коротко…",
        "filter-parameters_title": "Параметры фильтра",
        "filter-parameters_subtitle1": "Определяемся с типами матриц",
        "filter-parameters_item1": "Вектор состояния системы",
        "filter-parameters_item2": "Матрица эволюции системы",
        "filter-parameters_item3": "Матрица управления",
        "filter-parameters_item4": "Вектор управления",
        "filter-parameters_item5": "Матрица измерений равна единичной матрице",
        "several-operation_title": "Реализовываем несколько операций с матрицами",
        "several-operation_desc": "Матрица измерений равна единичной матрице, если GPS -приемник предоставляет информацию о скорости. Если же GPS-приемник предоставляет только координаты, то матрица примет такой вид:",
        "several-operation_pic1": "рис. 1",
        "several-operation_p1": "Второй вариант показывает лучший результат при кратковременной потере GPS сигнала, потому что на вектор состояния не влияет последняя полученная от приёмника скорость.",
        "several-operation_pic2": "рис. 2 Ковариационная матрица шума измерений",
        "several-operation_p2": "Если GPS приемник не предоставляет информацию о скорости объекта. В противном случае:",
        "several-operation_pic3": "рис. 3",
        "several-operation_p3": "Можно распарсить NMEA сообщение и использовать компонент HDOP, можно использовать класс Location и метод getAccuracy(). Чтобы получить скорость в нашей системе координат необходимо получить направление. Это либо компонент course в NMEA сообщении, либо bearing из объекта Location.",
        "several-operation_pic4": "Рис. 4 Ковариационная матрица шума процесса",
        "several-operation_p4": "Из-за интегрирования показаний акселерометра ошибка позиционирования, связанная с акселерометром, будет увеличиваться с течением времени. Соответственно, мы должны будем меньше полагаться на данные акселерометра и, в конечном итоге, должны будем принять координату от GPS приемника, а не от акселерометра. Dt —  время между двумя шагами update (между получением GPS координат) фильтра Калмана.",
        "filter-parameters_subtitle2": "Чтобы фильтр Калмана работал, нужно привести все данные к единой системе координат.",
        "geohash_title": "GeoHash",
        "geohash_subtitle": "Алгоритм для преобразования двух координат вида 42.8795949 (долгота), 74.5998444 (широта) в одну строку",
        "geohash_p1": "В данном проекте используется для решения двух проблем. Во-первых, необходимо как-то объединить находящиеся рядом точки, чтоб снизить поток избыточной информации. Для этого можно выбрать какой-нибудь радиус и объединять все точки, попадающие в окружность с этим радиусом. Но как выбрать радиус и центр этой окружности? Вычисление расстояния в сферических координатах  —  дорогостоящая операция, поэтому была использована geohash функция, которая позволяет очень быстро определить, относятся ли точки к одной области или нет. Эта функция выдает хэш в виде строки, длина которой определяется пользователем и влияет на точность кодирования. Чем больше длина хэша, тем меньше область и больше точность координат в одной области. Максимальная возможная длина геохэш-строки — 12 символов. Очень хороший результат показывает длина хэша 7 или 8 символов.",
        "geohash_subtitle2": "Ещё одно применение этой функции",
        "geohash_p2": "Определение и фильтрация «скачков». Мы будем считать, что если GPS приемник выдал подряд больше трех (параметр задается пользователем) координат с одним хэшем, то эта точка правильная и её нужно учитывать. Если же меньше — то, вероятно, это какое-то случайное значение, которое не нужно учитывать.",
        "geohash_p3": "Маршрут без применения фильтра, основанного на GeoHash",
        "geohash_p3.2": "Маршрут с применением фильтра на основе GeoHash. Длина строки (precision) — 8. Минимальное количество точек с одним геохэшем — 2",
        "geohash_p3.3": "Маршрут с применением фильтра на основе GeoHash. Длина строки (precision) — 7. Минимальное количество точек с одним геохэшем — 3",
        "geohash_p4": "Как видно из приведенных примеров, GeoHash фильтр позволяет значительно сократить количество обрабатываемых точек. Это может быть критичным, если координаты обрабатываются сервером или если планируется сохранять маршруты в базе данных.",
        "geohash_subtitle3": "Результат работы, вывод и дальнейшие улучшения",
        "geohash_p5": "В результате был написан Android модуль и библиотека на C, реализующие все вышеперечисленный фильтры. Визуально тракетории стали более сглаженными и исчезло накручивание дистанции при отсутствии движения. Как следствие  — улучшился подсчет пройденной дистанции.",
        "geohash_p6": "Красные точки — координаты GPS, а синие — результат работы фильтра. Как видно была небольшая потеря связи с GPS, но траектория успешно восстановлена",
        "geohash_p7": "Зелёная линия  - сильно зашумленные данные GPS. Красный  -  результат фильтрации (сначала Калман, затем на основе GeoHash).",
        "geohash_p8": "Для подсчета дистанции использовались два алгоритма. Один из них  —  алгоритм Винченти. Он используется внутри метода distanceBetween() класса Location. Второй метод: <a href='https://en.wikipedia.org/wiki/Great-circle_distance' target='_blank'>https://en.wikipedia.org/wiki/Great-circle_distance</a> (раздел с haversine формулой). Тесты показывают, что результат почти не отличается. Притом, второй вариант затрачивает намного меньше ресурсов. Однако есть подозрение, что на больших дистанциях погрешность будет больше. Тем не менее, в пределах города второй алгоритм показывает такой же результат, как и первый.",
        "geohash_link": "<a href='https://medium.com/@lezh1k.vohrer/b81f1026e06c' target='_blank'><img src='img/right.svg', alt='Right'>Детали расчетов можно посмотреть в блоге</a>",
        "use_dev_title": "Используй и развивай",
        "use_dev_desc": "Данное решение имеет лицензию <a href='https://opensource.org/licenses/MIT' target='_blank'>MIT</a> не забывайте про копирайты и указывайте авторство",
        "use_dev_or": "или",
        "use_dev_libs": "Библиотека на GitHub",
        "use_dev_docs": "Документация и теория",
        "footer_title": "Вся магия случилась благодаря",
        "footer_desc": "Для консультации, благодарности или для получения услуг по внедрению библиотеки пишите нам <a href='mailto:rock@maddevs.io' target='_blank'> rock@maddevs.io <img src='img/footer/hand.png', alt='Hand'></a>"
    },
    "en": {
        "main-menu_item1": "Home",
        "main-menu_item2": "Why do I need a filter?",
        "main-menu_item3": "What can?",
        "main-menu_item4": "How does it work?",
        "main-menu_item5": "How to use?",
        "main-menu_item6": "Who did?",
        "main-menu_item7": "на русском",
        "logo_desc": "Accurate and «pure» Data from GPS-receivers",
        "lang-toggle": "на русском",
        "main_title": "Error filter for GPS-receivers",
        "without_filter": "without filter",
        "with_filter": "with filter",
        "lib_github": "Library on Github",
        "main-banner_or": "or",
        "docs": "Documentation",
        "why-is-this_title": "Why do you need Mad Location Manager?",
        "why-is-this_p1": "Are you tired of «extra» kilometers duу to an inaccuracy of GPS-data in taxi applications?",
        "why-is-this_p2": "Are there regular sharp «jumps» in the Applications for Courier tracking? ",
        "why-is-this_p3": "Do you need precise tracking in an on-demand service?",
        "why-is-this_subtitle": "The solution is Mad Location Manager",
        "features_title": "What are the features of Mad Location Manager?",
        "features_p1": "It reduces the errors in route tracking",
        "features_p2": "It allows making motion of the objects on the map",
        "features_p3": "It eliminates additional distance when the object is motionless",
        "features_p4": "It decreases the noise from Low-class smartphones",
        "features_p5": "It excludes sharp «jumps» to the points remote from a real route",
        "features_p6": "It filters errors duу to the short-term loss of GPS-signal",
        "features_subtitle": "In addition, it solves the other tasks related to the delivery and tracking of the objects moving on the map",
        "features_how_work": "How does it work?",
        "how-it-work_title": "How does it work?",
        "how-it-work_subtitle": "To implement the system we need data from the following three sensors:",
        "how-it-work_item1_title": "Magnetometer",
        "how-it-work_item1_desc": "Shows where the North is",
        "how-it-work_item2_title": "Accelerometer",
        "how-it-work_item2_desc": "Is used for acceleration measurement and angle determination",
        "how-it-work_item3_title": "Gyroscope",
        "how-it-work_item3_desc": "Allows us to get the current position of the object through the integration of gyroscope readings given the initial object position",
        "android-sensors_title": "The simplest and the most convenient are virtual Android sensors",
        "rotation_vector_title": "We have an acceleration vector in the “absolute” coordinate system and we can implement Kalman filter",
        "rotation_vector_item1_title": "Virtual Android sensors",
        "rotation_vector_item1_desc": "We can use a LINEAR_ACCELERATION sensor for linear accelerations (excluding gravity force) and ROTATION_VECTOR sensor for device orientation",
        "rotation_vector_item2_title": "Kalman filter",
        "rotation_vector_item2_desc": "We determine the state vector of the system, the transition matrix, the control vector, and other components of the Kalman filter. Then define the covariance noise matrix of the process and measurement noise. In this form, it is relatively easy to implement the filter",
        "rotation_vector_simple": "To make the long story short…",
        "filter-parameters_title": "Filter parameters",
        "filter-parameters_subtitle1": "Now we have to determine the types of matrixes",
        "filter-parameters_item1": "System state vector",
        "filter-parameters_item2": "State-transition model",
        "filter-parameters_item3": "Control-input mode",
        "filter-parameters_item4": "Control Vector",
        "filter-parameters_item5": "Observation model",
        "several-operation_title": "Perform several operations with matrices",
        "several-operation_desc": "The observation model maps the true state space into the observed space. In our case, it equals to identity matrix as we can get everything from a GPS receiver (speed and coordinates) and don’t need to convert it. If the receiver can’t get information about speed then an observation model changes to this:",
        "several-operation_pic1": "pic. 1",
        "several-operation_p1": "The second one shows the better result with a short-term loss of the GPS signal because the state vector is not affected by the last speed received from a receiver.",
        "several-operation_pic2": "pic.2 Covariance noise measurement matrix",
        "several-operation_p2": "If a receiver doesn’t provide information about speed. Otherwise:",
        "several-operation_pic3": "pic. 3",
        "several-operation_p3": "These values could be received in different ways. You can parse NMEA message and use HDOP value. Also, you can use Location class getAccuracy() method. We should know the direction to get speed to in our coordinate system. For this, we can use either course component from NMEA message or getBearing() method from Location class.",
        "several-operation_pic4": "pic. 4 Process noise covariance matrix",
        "several-operation_p4": "Over time the positioning error due to the integration of accelerometer readings will increase. Therefore, we have to take GPS-coordinate as the result instead of accelerometer reading. Dt is the period between 2 update steps (obtaining of GPS-coordinates) in Kalman filter.",
        "filter-parameters_subtitle2": "To make Kalman filter work, we have to bring all the data to the single coordinate system.",
        "geohash_title": "GeoHash",
        "geohash_subtitle": "The algorithm for converting two coordinates of the form 42.8795949 (longitude), 74.5998444 (latitude) into one line",
        "geohash_p1": "In this project, it is used to solve 2 problems. First, it is necessary to somehow merge the nearby points to reduce the flow of redundant information. To do this, you can select a radius and merge all the points that fall into the circle with this radius. But how to choose the radius and center of this circle? Calculating the distance in spherical coordinates is a costly operation, so a GeoHash function is used to “join” fast coordinates. This function produces a hash as a string, the length of which is determined by the user and affects the encoding accuracy. The longer the hash length is, the smaller the region is and the greater accuracy of the coordinates is in one region. The maximum possible length of a GeoHash string is 12 characters. A very good result for our task shows hash with 7 and 8 precision.",
        "geohash_subtitle2": "Another application of this function",
        "geohash_p2": "Another way to use this function is “jumps” filtering. We will assume that if the GPS receiver has given out more than 3 (user-defined count) coordinates with one hash, then this point is correct and it should be taken into account. If less — then, probably, this is some random value that does not need to be taken into account.",
        "geohash_p3": "A route without the implementation of the GeoHash-based filter",
        "geohash_p3.2": "A route with GeoHash-based filter. The length of the string (accuracy) is 8. The minimum number of points with one geohash is 2",
        "geohash_p3.3": "A route with GeoHash-based filter. The length of the string (accuracy) is 7. The minimum number of points with one geohash is 3",
        "geohash_p4": "Examples above illustrate that GeoHash filter allows to significantly reduce the number of processing coordinates. It may be crucial if coordinates are planned to be processed by the server or to save the routes in the database.",
        "geohash_subtitle3": "Result, conclusion and further improvements",
        "geohash_p5": "As a result, we wrote an Android module and a C library that implements all of the above filters. Visually routes became smoothed and calculation error was reduced.",
        "geohash_p6": "Red points are GPS coordinate. Blue points — filtered values.",
        "geohash_p7": "Green line shows GPS data with significant nose. Red one - filtered data (firstly, by Kalman filter, than by filter based on GeoHash)",
        "geohash_p8": "Two algorithms were used to calculate the distance. One of them is the Vincenti algorithm. It is used inside of the distanceBetween() method of the Location class. The second method: <a href='https://en.wikipedia.org/wiki/Great-circle_distance' target='_blank'>https://en.wikipedia.org/wiki/Great-circle_distance</a> (section with the haversine formula). Tests show that the results are almost the same, while the second option requires fewer resources. Yet, there are high chances that at greater distances the error will be greater. Within the city, both algorithms will operate the same way.",
        "geohash_link": "<a href='https://medium.com/@lezh1k.vohrer/43594faed19c' target='_blank'><img src='img/right.svg', alt='Right'>You can see calculation details in our blog</a>",
        "use_dev_title": "Use and develop",
        "use_dev_desc": "The solution if licensed by <a href='https://opensource.org/licenses/MIT' target='_blank'>MIT</a>. Therefore, do not Forget about the copyrights and authorship",
        "use_dev_or": "or",
        "use_dev_libs": "Library on Github",
        "use_dev_docs": "Documentation",
        "footer_title": "All the magic happened thanks to MadDevs",
        "footer_desc": "To express gratitude or to get consultation or assistance in the system implementation write to <a href='mailto:rock@maddevs.io' target='_blank'>rock@maddevs.io <img src='img/footer/hand.png' alt='Hand'></a>"
    }
}

 


